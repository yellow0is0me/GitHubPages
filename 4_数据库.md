
## **数据库**
### **1 基础**
#### **1.1 三范式**
	
	|-- 每一列属性都是不可再分的属性值，确保每一列的原子性
	|-- 每一行的数据只能与其中一列相关，即一行数据只做一件事。
		  只要数据列中出现数据重复，就要把表拆分开来。
	|-- 数据不能存在传递关系

#### **1.2 事务**
	
	ACID：原子性，隔离型，一致性，永久性
#### **1.3 隔离级别**
	
	|-- 未提交读（Read-Uncommitted)
			|-- 脏读:一个事务读取到了其他事务还没有提交的数据
	|-- 已提交读（Read-Committed)
			|-- 不可重复读:一个事务在进行中读取到了其他事务对旧数据的修改结果
	|-- 可重复读（Repetable-Read)
			|-- 幻读:一个事务中，读取到了其他事务新增的数据
	|-- 可串行化（Serializable)
	
### **2 MySQL**
#### **2.1 存储引擎**
	
	|-- Myisam：不支持事务的概念，不支持行级锁，非聚簇索引
				多用于数据仓库这样查询多而事务少的情况，速度较快
	|-- InnoDB：支持事务的概念，支持行级锁，聚簇索引
				多用于web网站后台等实时的中小型事务处理后台。
#### **2.2 索引**
	
	高效获取数据的数据结构
索引的优缺点：
	
	优势：可以快速检索，减少I/O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序；
	劣势：索引本身也是表，因此会占用存储空间
		 索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大
		 构建索引会降低数据表的修改操作的效率
索引的分类：
	
	|-- 主键索引：主索引，根据主键pk_clolum（length）建立索引，不允许重复，不允许空值
			PRIMARY KEY
	|-- 唯一索引：建立索引的列的值必须是唯一的，允许空值
			UNIQUE
	|-- 普通索引：辅助索引，二级索引，表中的普通列构建的索引，没有任何限制
			INDEX
	|-- 全文索引：大文本对象的列构建的索引
			FULLTEXT INDEX
	|-- 组合索引：多个列组合构建的索引，这多个列中的值不允许有空值
			INDEX
索引的实现：
	
	|-- BTree索引
	|-- B+Tree索引：
			|-- 磁盘读写代价更低
			|-- 查询速度更稳定
			|-- 叶子节点形成有序链表，便于执行范围操作
			|-- 聚集索引中，叶子节点的data直接包含数据；
				非聚集索引中，叶子节点存储数据地址的指针
expain：
	
	|-- id:选择标识符
			|-- id相同，可以认为是一组，从上往下顺序执行
			|-- id值越大，优先级越高，越先执行
	|-- select_type:表示查询的类型。
	|-- table:输出结果集的表
	|-- partitions:匹配的分区
	|-- type:表示表的连接类型
	|-- possible_keys:表示查询时，可能使用的索引
	|-- key:表示实际使用的索引
	|-- key_len:索引字段的长度
	|-- ref:列与索引的比较
	|-- rows:扫描出的行数(估算的行数)
	|-- filtered:按表条件过滤的行百分比
	|-- Extra:执行情况的描述和说明

#### **2.3 锁**

	|-- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
	|-- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
	|-- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；并发度一般
	
PS: 间隙锁（Next-Key锁）
> 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）

#### **2.4 MVCC**
> Multi-Version Concurrency Control：多版本并发控制

	通过保存数据在某个时间点的快照来实现的。
	这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。
	根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。

#### **2.5 数据同步**

	|-- 异步复制：
		1.Slave的IO线程请求Master日志内容
		2.Master将指定位置的BinaryLog返回给Slave
		3.Slave的IO线程结束数据，记录在Relay log末端
		4.Slave的SQL线程解析Log并执行
	|-- 半同步复制：
		1.Master将每个事务写入binlog
		2.传递到Slave刷新到磁盘
		3.（两种方式）
			3.1 Master提交，等待slave反馈
			3.2 等待Slave反馈，Master提交
		4.Master反馈给客户端OK
	|-- 全同步复制：
		1.主节点上写入的数据
		2.服务器上都同步完成
		3.给客户端返回成功



















